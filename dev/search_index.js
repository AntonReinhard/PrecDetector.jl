var documenterSearchIndex = {"docs":
[{"location":"lib/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Types","page":"Public","title":"Types","text":"","category":"section"},{"location":"lib/public/#PrecDetector.PrecCarrier","page":"Public","title":"PrecDetector.PrecCarrier","text":"PrecCarrier{AbstractFloat}\n\nA carrier type for floating points. Most math functions are overloaded for this type. Initialize it with some value (or see precify to convert an entire array or tuple type of numbers), do some arithemitc with your value(s), and finally, print it to check the number of accumulated epsilons of error.\n\njulia> using PrecDetector\n\njulia> function unstable(x, N)\n           y = abs(x)\n           for i in 1:N y = sqrt(y) end\n           w = y\n           for i in 1:N w = w^2 end\n           return w\n       end\nunstable (generic function with 1 method)\n\njulia> unstable(precify(2), 5)\n1.9999999999999964 <ε=8>\n\njulia> unstable(precify(2), 10)\n2.0000000000000235 <ε=53>\n\njulia> unstable(precify(2), 20)\n2.0000000001573586 <ε=354340>\n\njulia> unstable(precify(2), 128)\n1.0 <ε=4503599627370496>\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Functions","page":"Public","title":"Functions","text":"","category":"section"},{"location":"lib/public/#PrecDetector.precify","page":"Public","title":"PrecDetector.precify","text":"precify([::Type{PrecCarrier{T}}], t::Any) where {T<:AbstractFloat}\nprecify([::Type{T}], t::Any) where {T<:AbstractFloat}\n\nConvert a number or container to a container of PrecCarriers. If no specific float type for the PrecCarrier is specified, the type of ts floats will be used.\n\njulia> using PrecDetector\n\njulia> precify((0, 1.0, 2.0f0))\n(0.0 <ε=0>, 1.0 <ε=0>, 2.0 <ε=0>)\n\njulia> typeof(ans)\nTuple{PrecCarrier{Float64}, PrecCarrier{Float64}, PrecCarrier{Float32}}\n\njulia> precify(PrecCarrier{Float32}, [0, 1.0, 2.0f0])\n3-element Vector{PrecCarrier{Float32}}:\n 0.0 <ε=0>\n 1.0 <ε=0>\n 2.0 <ε=0>\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PrecDetector.significant_digits","page":"Public","title":"PrecDetector.significant_digits","text":"significant_digits(p::PrecCarrier{T})\n\nReturn the number of significant decimal digits currently carried by this PrecCarrier.\n\njulia> using PrecDetector\n\njulia> function unstable(x, N)\n           y = abs(x)\n           for i in 1:N y = sqrt(y) end\n           w = y\n           for i in 1:N w = w^2 end\n           return w\n       end\nunstable (generic function with 1 method)\n\njulia> unstable(precify(0.5), 30)\n0.4999999971854335 <ε=25351362>\n\njulia> significant_digits(ans)\n8.249558460661778\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PrecDetector.reset_eps!","page":"Public","title":"PrecDetector.reset_eps!","text":"reset_eps!(p::PrecCarrier{AbstractFloat})\n\nReset the precision carrier to zero epsilons. Can be called on containers (AbstractArrays or Tuples) to reset all underlying PrecCarriers.\n\njulia> using PrecDetector\n\njulia> function unstable(x, N)\n           y = abs(x)\n           for i in 1:N y = sqrt(y) end\n           w = y\n           for i in 1:N w = w^2 end\n           return w\n       end\nunstable (generic function with 1 method)\n\njulia> p = unstable(precify(1.5), 30)\n1.4999996689838975 <ε=993842883>\n\njulia> reset_eps!(p)\n1.4999996689838975 <ε=0>\n\nCustom types can be overloaded by implementing a function dispatching the call downwards to all relevant members. Note that this is a muting operation and therefore requires mutability of the members.\n\nfunction reset_eps!(x::Custom)\n    reset_eps!(x.v1)\n    reset_eps!(x.v2)\n    # ...\n    return x\nend\n\n\n\n\n\n","category":"function"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using PrecDetector","category":"page"},{"location":"manual/#Precify","page":"Manual","title":"Precify","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Create a PrecCarrier object from any floating point by using precify:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"p = precify(1.0)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"By default, precify uses the type of the given floating point:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"typeof(precify(1.0f0))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"typeof(precify(Float16(1.0)))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"One can also specify the type:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"typeof(precify(Float32, 1.0))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"All of these versions also work on array and tuple types:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"precify((1.0, Float32(2.0), Float16(3.0)))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The interface can also easily be extended for custom types by dispatching to all relevant members:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"struct A\n    x::AbstractFloat\nend\n\nPrecDetector.precify(T::Type{<:PrecCarrier}, a::A) = A(precify(a.x))\n\nprecify(A(1.0))","category":"page"},{"location":"manual/#Arithmetic-and-Precision-Estimation","page":"Manual","title":"Arithmetic and Precision Estimation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The resulting precified object can be used like a normal floating point number:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"p = atan((p + 10)^2 * pi)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"When displaying the result, the number of epsilons (ε) is calculated. It represents the number of machine precision of the underlying floating point type, that it differs relative to the arbitrary precision calculation.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"p = tan(p)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The result is also color graded to draw attention to values that have precision problems.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The number of significant digits remaining in the type can be calculated by using significant_digits:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"significant_digits(p)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally, the precision carried can be reset using reset_eps!:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"reset_eps!(p)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contribution/#Contribution","page":"Contribution","title":"Contribution","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Feel free to open issues or pull requests to the official repository. Ideas, tips, bug reports, or contributions are all welcome.","category":"page"},{"location":"#PrecDetector.jl","page":"PrecDetector.jl","title":"PrecDetector.jl","text":"","category":"section"},{"location":"","page":"PrecDetector.jl","title":"PrecDetector.jl","text":"(Image: docs)","category":"page"},{"location":"","page":"PrecDetector.jl","title":"PrecDetector.jl","text":"This is a package to find imprecisions in chains of arithmetic functions.","category":"page"},{"location":"#How-it-Works","page":"PrecDetector.jl","title":"How it Works","text":"","category":"section"},{"location":"","page":"PrecDetector.jl","title":"PrecDetector.jl","text":"This package provides a new type, PrecCarrier{T}, which holds both a standard floating point type, and an arbitrary precision BigFloat. Basic arithmetic, trigonometric, and comparison functions are overloaded for this type and always work on both the basic and the arbitrary precision type. When some computations have been done, the values may (or may not) diverge, and the extent of the accumulated precision loss can be evaluated.","category":"page"},{"location":"","page":"PrecDetector.jl","title":"PrecDetector.jl","text":"This is not a package to directly increase the precision of your calculations. It is only intended to find the issues. To improve precision, you can use higher precision types, use arbitrary precision packages, or rearrange terms to be more numerically stable.","category":"page"},{"location":"#Usage","page":"PrecDetector.jl","title":"Usage","text":"","category":"section"},{"location":"","page":"PrecDetector.jl","title":"PrecDetector.jl","text":"A floating point number can simply be wrapped in the custom type by calling precify on it. This also works for tuples and arrays, and custom types if an implementation is provided for it. The resulting PrecCarrier object can then be used like any AbstractFloat type in most cases. Finally, with significant_digits, the number of remaining significant digits in the variable can be queried.","category":"page"},{"location":"","page":"PrecDetector.jl","title":"PrecDetector.jl","text":"using PrecDetector\n\n# example function from Prof. Kahan: https://people.eecs.berkeley.edu/~wkahan/WrongR.pdf\nfunction unstable(x, N)\n    y = abs(x)\n    for i in 1:N y = sqrt(y) end\n    w = y\n    for i in 1:N w = w^2 end\n    return w\nend\n\np = precify(1.5)\n\nsignificant_digits(p) # -> 15.65...\n\np = unstable(p, 20)\n\nsignificant_digits(p) # -> 10.39...\n\n# reset the precision carrier\nreset_eps!(p)","category":"page"},{"location":"#Caveats","page":"PrecDetector.jl","title":"Caveats","text":"","category":"section"},{"location":"","page":"PrecDetector.jl","title":"PrecDetector.jl","text":"This method, while helpful in many cases, is not universal and should be used with care:","category":"page"},{"location":"","page":"PrecDetector.jl","title":"PrecDetector.jl","text":"Some iterative methods (for a simple example, Newton's method) are not very reliant on high precision in every step, since they converge regardless of the precision of intermediate results. This can lead to something that looks like horrible precision loss, but is not actually relevant.\nThe given number of epsilons is not the same as an error of measurement. It should not be used for error bars or similar. It's rather a rough indicator of numerical noise, but for example it can statistically happen that imprecisions cancel each other for certain cases, but this does not indicate better stability.\nEven arbitrary precision has its limits. For the unstable function given above, at about N=256, even the BigFloat will become unstable and the program will incorrectly report perfect precision (because both the normal float and the big float are equally wrong). However, this should only happen in extreme cases where you are likely aware of this.\nBigFloat is not usable on GPUs.\nThe use of arbitrary precision adds considerable performance overhead.","category":"page"},{"location":"lib/internal/#Internal-functions-and-functionality","page":"Internal","title":"Internal functions and functionality","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Pages = [\"internal.md\"]","category":"page"},{"location":"lib/internal/#Functions","page":"Internal","title":"Functions","text":"","category":"section"},{"location":"example/#Usage-Example","page":"Example","title":"Usage Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Suppose we have the problem of computing the square root of the positive difference of two squares, x and y. The formula is simple: sqrtleftx^2 - y^2right. Let's write it in julia:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"f(x, y) = sqrt(abs(x^2 - y^2))\n\nf(5, 4)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"So far so good. Now what happens when x and y have almost equal values?","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"f(3.0 + 1.0e-7, 3.0)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Compare that with a result in arbitrary precision:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"f(big(3.0 + 1.0e-7), big(3.0))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Clearly, not all of the supposed ca. 15 digits that the Float64 result carries are correct. Let's see what PrecDetector says:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using PrecDetector\np = f(precify(3.0 + 1.0e-7), precify(3.0))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"significant_digits(p)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"It looks like we lost about 5 significant digits! This happens because of the intermediate results of x^2 and y^2 do not carry enough precision to accurately calculate their difference. This is often called \"catastrophic cancellation\", because the two values are almost equal, so many of the most-significant bits are \"cancelled\".","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In this instance, we can resolve the problem for most cases by replacing x^2 - y^2 with its binomial representation (x + y) * (x - y). This reduces the instability of the intermediate values:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"f_improved(x, y) = sqrt(abs((x + y) * (x - y)))\np = f_improved(precify(3.0 + 1.0e-7), precify(3.0))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"significant_digits(p)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We can now also easily visualize the precision loss of either version by plotting the significant digits on an x-y-plane:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using CairoMakie\n\nx = 1.0:1.0e-6:(1.0 + 1.0e-4)\ny = 1.0:1.0e-6:(1.0 + 1.0e-4)\n\ncontourf(x, y, (x, y) -> significant_digits(f(precify(x), precify(y))))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"With a little more effort we can compare the two versions on some values:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"fig = Figure()\n\nz1 = [significant_digits(f(precify(xi), precify(yi))) for yi in y, xi in x]\nz2 = [significant_digits(f_improved(precify(xi), precify(yi))) for yi in y, xi in x]\n\nzmin = floor(Int64, min(minimum(z1), minimum(z2)))\nzmax = ceil(Int64, max(maximum(z1), maximum(z2)))\n\nax1 = Axis(fig[1, 1]; aspect = AxisAspect(1), title = \"Original f\", xticksvisible = false, yticksvisible = false, xticklabelsvisible = false, yticklabelsvisible = false)\nax2 = Axis(fig[1, 2]; aspect = AxisAspect(1), title = \"Improved f\", xticksvisible = false, yticksvisible = false, xticklabelsvisible = false, yticklabelsvisible = false)\n\ncontour1 = contourf!(ax1, x, y, z1; levels = range(zmin, zmax))\ncontour2 = contourf!(ax2, x, y, z2; levels = range(zmin, zmax))\n\nColorbar(fig[1, 3], contour1; label = \"Significant Digits\")\n\nfig","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This page was generated using Literate.jl.","category":"page"}]
}
